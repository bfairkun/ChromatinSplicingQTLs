
configfile: "config/config.yaml"

include: "rules/common.smk"
# include: "rules/other.smk"
# include: "rules/DownloadData.smk"
# include: "rules/RNASeqProcessing.smk"
# include: "rules/Genotypes.smk"
# include: "rules/ChIPSeqProcessing.smk"
# include: "rules/PlotGruberExamples.smk"
# include: "rules/RASQUAL.smk"

wildcard_constraints:
    chrom="|".join(autosomes),
    IndID="|".join(Fastq_samples['IndID']),
    Rep="\d+"

localrules: all, CopyFastqFromLocal, DownloadFastqFromLink, Download1KG_GRCh38, STAR_make_index
ruleorder: CopyFastqFromLocal > DownloadFastqFromLink

ChromatinProfilingPhenotypes = Fastq_samples.loc[ (Fastq_samples['Assay'].isin(["ChIP-seq", "CutAndTag"]))  ]['Phenotype'].unique()
RNASeqPhenotypes = Fastq_samples.loc[ (Fastq_samples['Assay']=="RNA-seq")  ]['Phenotype'].unique()
ChromatinProfilingSamples_df = Fastq_samples.loc[ (Fastq_samples['Assay'].isin(["ChIP-seq", "CutAndTag"])) , ['Phenotype', 'IndID', 'RepNumber'] ].drop_duplicates()
RNASeqSamples_df = Fastq_samples.loc[ (Fastq_samples['Assay']=="RNA-seq") , ['Phenotype', 'IndID', 'RepNumber'] ].drop_duplicates()


rule all:
    input:
        # expand( "Bigwigs/GEUVADIS_RNAseq/{RNASeqSample}.bw", RNASeqSample=GEUVADIS_line_fastq_dict.keys()),
        # expand( "Bigwigs/Grubert_ChIPSeq/{Antibody}.{Cell_Line}.bw", zip, Antibody=Grubert_ChIP_seq['Antibody'], Cell_Line=Grubert_ChIP_seq['Cell_Line']),
        # "Genotypes/GEUVADIS_1000G/All.vcf.gz",
        # # "Phenotypes/GEUVADIS_RNAseq/leafcutter/clustering/leafcutter_perind.counts.gz.PCs",
        # expand("logs/PlotGruberQTLs/PlotFromShellScript.{pheno}.log", pheno=["H3K4ME3", "H3K27AC", "H3K4ME1"]),
        # "Genotypes/GEUVADIS_1000G/All.Dummy.vcf",
        # expand("Phenotypes/GEUVADIS_RNAseq/BySample/{RNASeqSample}.junc", RNASeqSample=GEUVADIS_line_fastq_dict.keys()),
        # "Phenotypes/GEUVADIS_RNAseq/leafcutter/SplicingPhenotypesQQNormed.bed.gz",
        # # "QTLs/sQTLs/permuations_pass.txt.gz",
        # "QTLs/sQTLs/permutation_pass_chunks/1.1000.txt.gz",
        # expand("FastqFastp/{Phenotype}/{IndID}/{Rep}.R2.fastq.gz", zip, Phenotype=Fastq_samples['Phenotype'], IndID=Fastq_samples['IndID'], Rep=Fastq_samples['RepNumber']),
        # expand("ReferenceGenome/STAR_WASP_Vcfs/{Phenotype}/{chrom}.vcf", Phenotype=['Expression.Splicing'], chrom=autosomes),
        # "ReferenceGenome/STAR_WASP_Vcfs/Expression.Splicing/WholeGenome.vcf",
        # expand("ReferenceGenome/HornetSnpLists/{Phenotype}/chr{chrom}.snps.txt.gz", Phenotype="CTCF", chrom=autosomes)
        expand("Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.wasp_filterd.sorted.bam", zip, Phenotype= ChromatinProfilingSamples_df['Phenotype'], IndID=ChromatinProfilingSamples_df['IndID'], Rep=ChromatinProfilingSamples_df['RepNumber']),
        expand("Alignments/STAR_Align/{Phenotype}/{IndID}/{Rep}/Filtered.bam", zip, Phenotype=RNASeqSamples_df['Phenotype'], IndID=RNASeqSamples_df['IndID'], Rep=RNASeqSamples_df['RepNumber'])

rule Download1KG_GRCh38:
    output:
        vcf = "Genotypes/1KG_GRCh38/{chrom}.vcf.gz",
        tbi = "Genotypes/1KG_GRCh38/{chrom}.vcf.gz.tbi",
    log:
        "logs/Download1KG_GRCh38/{chrom}.log"
    params:
        aspera_key = config['aspera_key']
    wildcard_constraints:

    shell:
        """
        #Use aspera if aspera key file and aspera links parameters are defined (not empty strings)
        if [[ ! -z "{params.aspera_key}" ]]
        then
            ascp -i {params.aspera_key} -Tr -Q -l 100M -P33001 -L- fasp-g1k@fasp.1000genomes.ebi.ac.uk:vol1/ftp/data_collections/1000_genomes_project/release/20181203_biallelic_SNV/ALL.chr{wildcards.chrom}.shapeit2_integrated_v1a.GRCh38.20181129.phased.vcf.gz {output.vcf} &> {log}
            ascp -i {params.aspera_key} -Tr -Q -l 100M -P33001 -L- fasp-g1k@fasp.1000genomes.ebi.ac.uk:vol1/ftp/data_collections/1000_genomes_project/release/20181203_biallelic_SNV/ALL.chr{wildcards.chrom}.shapeit2_integrated_v1a.GRCh38.20181129.phased.vcf.gz.tbi {output.tbi} &>> {log}
        else
            curl -f -o {output.vcf} "http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000_genomes_project/release/20181203_biallelic_SNV/ALL.chr{wildcards.chrom}.shapeit2_integrated_v1a.GRCh38.20181129.phased.vcf.gz" &> {log}
            curl -f -o {output.tbi} "http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000_genomes_project/release/20181203_biallelic_SNV/ALL.chr{wildcards.chrom}.shapeit2_integrated_v1a.GRCh38.20181129.phased.vcf.gz.tbi" &>> {log}
        fi
        """

rule CopyFastqFromLocal:
    input:
        R1 = GetFastqLocalFuncs('R1_local'),
        R2 = GetFastqLocalFuncs('R2_local'),
    output:
        R1 = temp("Fastq/{Phenotype}/{IndID}/{Rep}.R1.fastq.gz"),
        R2 = temp("Fastq/{Phenotype}/{IndID}/{Rep}.R2.fastq.gz")
    log:
        "logs/MoveFastqFromLTS/{Phenotype}.{IndID}.{Rep}.log"
    shell:
        """
        cat {input.R1} > {output.R1} 2> {log}
        cat {input.R2} > {output.R2} 2>> {log}
        """

rule DownloadFastqFromLink:
    input:
        aspera_key = config['aspera_key']
    output:
        R1 = temp("Fastq/{Phenotype}/{IndID}/{Rep}.R1.fastq.gz"),
        R2 = temp("Fastq/{Phenotype}/{IndID}/{Rep}.R2.fastq.gz")
    log:
        "logs/DownloadFastqFromAsperaLink/{Phenotype}.{IndID}.{Rep}.log"
    params:
        R1_ftp = GetDownloadLinkFuncs('R1_ftp'),
        R2_ftp = GetDownloadLinkFuncs('R2_ftp'),
        R1_aspera = GetDownloadLinkFuncs('R1_aspera'),
        R2_aspera = GetDownloadLinkFuncs('R2_aspera'),
    shell:
        """
        #Use aspera if aspera key file and aspera links parameters are defined (not empty strings)
        if [[ ! -z "{input.aspera_key}" && ! -z "{params.R1_aspera}" && ! -z "{params.R2_aspera}" ]]
        then
            ascp -v -QT -l 300m -P33001 -i {input.aspera_key} era-fasp@{params.R1_aspera} {output.R1} &> {log}
            ascp -v -QT -l 300m -P33001 -i {input.aspera_key} era-fasp@{params.R2_aspera} {output.R2} &> {log}
        else
            wget -O {output.R1} {params.R1_ftp} &> {log}
            wget -O {output.R2} {params.R2_ftp} &>> {log}
        fi
        """

rule fastp:
    """
    clips adapters, can handle UMIs
    """
    input:
        R1 = "Fastq/{Phenotype}/{IndID}/{Rep}.R1.fastq.gz",
        R2 = "Fastq/{Phenotype}/{IndID}/{Rep}.R2.fastq.gz"
    output:
        R1 = "FastqFastp/{Phenotype}/{IndID}/{Rep}.R1.fastq.gz",
        R2 = "FastqFastp/{Phenotype}/{IndID}/{Rep}.R2.fastq.gz",
        html = "FastqFastp/{Phenotype}/{IndID}/{Rep}.fastp.html",
        json = "FastqFastp/{Phenotype}/{IndID}/{Rep}.fastp.json"
    params:
        GetFastpParams
    resources:
        mem_mb = 8000
    log:
        "logs/fastp/{Phenotype}.{IndID}.{Rep}.log"
    conda:
        "envs/fastp.yml"
    shell:
        """
        fastp -i {input.R1} -I {input.R2} -o {output.R1} -O {output.R2} --html {output.html} --json {output.json} {params} &> {log}
        """

rule MakeHisat2Index:
    input:
        "ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa"
    output:
        ht1 = "ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa.1.ht2"
    log:
        "logs/MakeIndex.log"
    conda:
        "envs/hisat2.yml"
    threads: 8
    resources:
        mem_mb = 42000
    shell:
        """
        hisat2-build {input} {input} -p {threads} &> {log}
        """


rule STAR_make_index:
    """
    did not work on bigmem2. Never figured out why (the log file didn't
    indicate anything). Ran on login node with success.
    """
    input:
        fasta = "ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa",
        gtf = "ReferenceGenome/Annotations/gencode.v34.primary_assembly.annotation.gtf",
    output:
        index = "ReferenceGenome/STARIndex/chrLength.txt",
    log:
        "logs/STAR_make_index.log"
    params:
        genomeDir = "ReferenceGenome/STARIndex/"
    threads: 4
    resources:
        mem = "42G",
        partition = "bigmem2",
        ntasks = 5
    shell:
        """
        STAR --runMode genomeGenerate --genomeSAsparseD 2 --runThreadN {threads} --genomeDir {params.genomeDir} --sjdbGTFfile {input.gtf} --genomeFastaFiles {input.fasta} &> {log}
        """

rule MakeDummyVcfForSTAR_WASP_MODE:
    """
    https://github.com/alexdobin/STAR/issues/772
    The vcf for STAR WASP mode should contain genotypes for a single
    (personalized) sample, or contain genotypes for a dummy sample with
    heterozygous genotypes at all variant positions.
    """
    input:
        "Genotypes/1KG_GRCh38/{chrom}.vcf.gz"
    params:
        IndIDs = lambda wildcards: ",".join(Fastq_samples.loc[(Fastq_samples['Include']==True) & (Fastq_samples['Phenotype']==wildcards.Phenotype), ['IndID']].drop_duplicates()['IndID'])
    log:
        "logs/MakeDummyVcfForSTAR_WASP_MODE/{Phenotype}/{chrom}.log"
    output:
        vcf = "ReferenceGenome/STAR_WASP_Vcfs/{Phenotype}/{chrom}.vcf.gz",
        tbi = "ReferenceGenome/STAR_WASP_Vcfs/{Phenotype}/{chrom}.vcf.gz.tbi"
    shell:
        """
        (bcftools view -s {params.IndIDs} --force-samples -c 1:minor {input} | awk -F'\\t' -v OFS='\\t' '$1~"^##" {{print}} $1=="#CHROM" {{print $1,$2,$3,$4,$5,$6,$7,$8,$9,"DummyID"}} $1!~"^#" {{print $1,$2,$3,$4,$5,$6,$7,$8,$9,"0|1"}}' | bgzip -c /dev/stdin > {output}) &> {log}
        tabix -p vcf {output.vcf}
        """

rule MergeVcfForSTAR_WASP_MODE:
    input:
        vcf = expand("ReferenceGenome/STAR_WASP_Vcfs/{{Phenotype}}/{chrom}.vcf.gz", chrom=autosomes),
        tbi = expand("ReferenceGenome/STAR_WASP_Vcfs/{{Phenotype}}/{chrom}.vcf.gz.tbi", chrom=autosomes)
    output:
        vcf = "ReferenceGenome/STAR_WASP_Vcfs/{Phenotype}/WholeGenome.vcf",
    shell:
        """
        bcftools concat -O v {input.vcf} > {output.vcf}
        """

rule STAR_Align_WASP:
    input:
        index = "ReferenceGenome/STARIndex/chrLength.txt",
        R1 = "FastqFastp/{Phenotype}/{IndID}/{Rep}.R1.fastq.gz",
        R2 = "FastqFastp/{Phenotype}/{IndID}/{Rep}.R2.fastq.gz",
        vcf = "ReferenceGenome/STAR_WASP_Vcfs/{Phenotype}/WholeGenome.vcf"
    output:
        bam = temp("Alignments/STAR_Align/{Phenotype}/{IndID}/{Rep}/Aligned.sortedByCoord.out.bam")
    threads: 8
    log: "logs/STAR_Align_WASP/{Phenotype}/{IndID}.{Rep}.log"
    params:
        readMapNumber = -1,
        ENCODE_params = "--outFilterType BySJout --outFilterMultimapNmax 20  --alignSJoverhangMin 8 --alignSJDBoverhangMin 1 --outFilterMismatchNmax 999 --outFilterMismatchNoverReadLmax 0.04 --alignIntronMin 20 --alignIntronMax 1000000 --alignMatesGapMax 1000000",
        WASP_params = "--waspOutputMode SAMtag --outSAMattributes vW vG --varVCFfile"
    resources:
        cpus_per_node = 9,
        mem = 58000,
    wildcard_constraints:
        Phenotype = "Expression.Splicing|chRNA.Expression.Splicing"
    shell:
        """
        STAR --readMapNumber {params.readMapNumber} --outFileNamePrefix Alignments/STAR_Align/{wildcards.Phenotype}/{wildcards.IndID}/{wildcards.Rep}/ --genomeDir ReferenceGenome/STARIndex/ --readFilesIn {input.R1} {input.R2} --outSAMtype BAM SortedByCoordinate --readFilesCommand zcat --runThreadN {threads} --outSAMmultNmax 1 {params.WASP_params} {input.vcf} --limitBAMsortRAM 10000000000 {params.ENCODE_params} &> {log}
        """

rule FilterBAM_WaspTags:
    input:
        bam = "Alignments/STAR_Align/{Phenotype}/{IndID}/{Rep}/Aligned.sortedByCoord.out.bam"
    output:
        bam = "Alignments/STAR_Align/{Phenotype}/{IndID}/{Rep}/Filtered.bam",
        bai = "Alignments/STAR_Align/{Phenotype}/{IndID}/{Rep}/Filtered.bam.bai",
    log:
        "logs/FilterBAM_WaspTags/{Phenotype}/{IndID}.{Rep}.log"
    shell:
        """
        cat <(samtools view -H {input.bam}) <(samtools view {input.bam} | grep -v "vW:i:[2-7]") | samtools view -bh > {output.bam}
        samtools index {output.bam}
        """

rule Hisat2_Align:
    input:
        Ref = "ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa",
        ht1 = "ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa.1.ht2",
        R1 = "FastqFastp/{Phenotype}/{IndID}/{Rep}.R1.fastq.gz",
        R2 = "FastqFastp/{Phenotype}/{IndID}/{Rep}.R2.fastq.gz",
    output:
        bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.bam",
        bai = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.bam.bai"
    threads: 8
    conda:
        "envs/hisat2.yml"
    params:
        MaxPE_InsertLen = 1000
    log:
        "logs/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.log"
    resources:
        mem = 58000,
        cpus_per_node = 9
    shell:
        """
        (hisat2 -1 {input.R1} -2 {input.R2} -x ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa -p {threads} --no-spliced-alignment --no-discordant --maxins {params.MaxPE_InsertLen} | samtools view -bh -F256 | samtools sort -n | samtools fixmate -m - - |   samtools sort | samtools markdup - -  > {output.bam}) &> {log}
        samtools index {output.bam}
        """

rule FilterHisat2PE_dups:
    input:
        bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.bam",
        bai = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.bam.bai"
    output:
        bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.bam",
        bai = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.bam.bai"
    log:
        "logs/FilterHisat2PE_dups/{Phenotype}/{IndID}.{Rep}.log"
    shell:
        """
        samtools view -bh -F 3072 {input.bam} > {output.bam} 2> {log}
        samtools index {output.bam}
        """

rule MakeHornetSnpList:
    input:
        "Genotypes/1KG_GRCh38/{chrom}.vcf.gz"
    params:
        IndIDs = lambda wildcards: ",".join(Fastq_samples.loc[(Fastq_samples['Include']==True) & (Fastq_samples['Phenotype']==wildcards.Phenotype), ['IndID']].drop_duplicates()['IndID'])
    log:
        "logs/MakeHornetSnpList/{Phenotype}/{chrom}.log"
    output:
        snps = "ReferenceGenome/HornetSnpLists/{Phenotype}/chr{chrom}.snps.txt.gz",
    shell:
        """
        (bcftools view -H -s {params.IndIDs} -m2 -M2 -v snps --force-samples -c 1:minor {input} | awk -F'\\t' '{{ print $2, $4, $5 }}' | gzip - > {output} ) &> {log}
        """

rule Hornet_find_intersecting_snps:
    """
    keep: reads to keep that do not intersect snps
    remap: reads to remap. In fastq, the snp allele is switched
    """
    input:
        bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.bam",
        bai = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.bam.bai",
        snp_lists = expand("ReferenceGenome/HornetSnpLists/{{Phenotype}}/chr{chrom}.snps.txt.gz", chrom=autosomes)
    output:
        R1 = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.remap.fq1.gz",
        R2 = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.remap.fq2.gz",
        keep = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.keep.bam",
        remap = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.to.remap.bam"
    log:
        "logs/Hornet_find_intersecting_snps/{Phenotype}/{IndID}.{Rep}.log"
    resources:
        mem = 12000
    shell:
        """
        python scripts/Hornet/mapping/find_intersecting_snps.py -p {input.bam} ReferenceGenome/HornetSnpLists/{wildcards.Phenotype} &> {log}
        """

use rule Hisat2_Align as Hornet_Hisat2_Align with:
    input:
        Ref = "ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa",
        ht1 = "ReferenceGenome/Fasta/GRCh38.primary_assembly.genome.fa.1.ht2",
        R1 = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.remap.fq1.gz",
        R2 = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.remap.fq2.gz",
    output:
        bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.hornet.remapped.bam",
        bai = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.hornet.remapped.bam.bai"
    log:
        "logs/Horney_Hisat2_Align/{Phenotype}/{IndID}.{Rep}.log"

rule Hornet_filter_remapped:
    """
    check that remapped reads with allele siwtched map to same place. If they
    do, write to kept. Merge kept with keep from Hornet_find_intersecting_snps
    rule
    """
    input:
        remap_bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.hornet.remapped.bam",
        keep_bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.keep.bam",
        to_remap_bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.to.remap.bam"
    output:
        kept_bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.hornet.remapped.kept.bam",
        keep_bam_sorted = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.keep.sorted.bam",
        kept_bam_sorted = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.kept.sorted.bam",
        merged_bam = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.wasp_filterd.sorted.bam",
        merged_bai = "Alignments/Hisat2_Align/{Phenotype}/{IndID}.{Rep}.dedup.wasp_filterd.sorted.bam.bai",
    log:
        "logs/Hornet_filter_remapped/{Phenotype}/{IndID}.{Rep}.log"
    shell:
        """
        python scripts/Hornet/mapping/filter_remapped_reads.py {input.remap_bam} {input.to_remap_bam} {output.kept_bam} &> {log}
        samtools sort {input.keep_bam} -o {output.keep_bam_sorted}
        samtools sort {output.kept_bam} -o {output.kept_bam_sorted}
        samtools merge {output.merged_bam} {output.kept_bam_sorted} {output.keep_bam_sorted}
        samtools index {output.merged_bam}
        """

# rule ChromatinProfilingToBigwig:
#     input:
#         input
#     output:
#         output
#     log:
#         "logs/ChromatinProfilingToBigwig.log"
#     shell:
#         """
#         shell
#         """

# rule RNASeqToBigwig:
#     input:
#         input
#     output:
#         output
#     log:
#         "logs/RNASeqToBigwig.log"
#     shell:
#         """
#         shell
#         """

# def GetReplicateBams(wildcards):
#     if wildcards.P

# rule MergeReplicates:
#     input:
#         bams = GetReplicateBams
#     output:
#         bam = "Alignments/{Phenotype}/{IndID}.bam"
#         bai = "Alignments/{Phenotype}/{IndID}.bam.bai"
#     log:
#         "logs/MergeReplicates/{Phenotype}/{IndID}.log"
#     shell:
#         """
#         samtools merge {output.bam} {input} &> {log}
#         samtools index {output.bam}
#         """


# rule Macs2PeakCalling:
#     input:
#         bams = expand()
#     output:
#         peaks = "PeakCalling/H3K36me3/H3K36me3_peaks.broadPeak",
#         saf = "PeakCalling/H3K36me3/H3K36me3_peaks.broadPeak.saf"
#     shell:
#         """
#         macs2 callpeak --broad --name H3K36me3 --outdir PeakCalling/H3K36me3/ -t {input.bamsInCorrectPlace}
#         awk -F'\\t' -v OFS='\\t' 'BEGIN {{ print "GeneID", "Chr", "Start", "End", "Strand" }} {{ print $4, $1, $2, $3, $6 }}' {output.peaks} > {output.saf}
#         """
